{
  "filename": "rpc.md",
  "__html": "<h1>RPC框架扩展</h1>\n<p>RPC扩展主要是指在分布式事务框架下对传递控制参数的支持、与负载均衡的扩展控制。</p>\n<p>下面以dubbo框架为例讲解扩展的过程。</p>\n<ol>\n<li>传递控制参数的支持</li>\n</ol>\n<p>dubbo参数传递可以通过隐形传参的方式来完成。参数传递分为传出与接受两块。下面分别展示代码说明。</p>\n<p>dubbo传出参数的filter：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Activate</span>(group = Constants.CONSUMER)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DubboRequestInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Filter</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        <span class=\"hljs-comment\">//判断是否存在事务</span>\n        <span class=\"hljs-keyword\">if</span> (TracingContext.tracing().hasGroup()) {\n            <span class=\"hljs-comment\">//设置传递的参数信息</span>\n            RpcContext.getContext().setAttachment(TracingConstants.HEADER_KEY_GROUP_ID, TracingContext.tracing().groupId());\n            RpcContext.getContext().setAttachment(TracingConstants.HEADER_KEY_APP_MAP, TracingContext.tracing().appMapBase64String());\n        }\n        <span class=\"hljs-keyword\">return</span> invoker.invoke(invocation);\n    }\n}\n\n</code></pre>\n<p>dubbo传入参数的filter:</p>\n<pre><code class=\"language-java\">\n<span class=\"hljs-meta\">@Activate</span>(group = {Constants.PROVIDER})\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TracingHandlerInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Filter</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        <span class=\"hljs-comment\">//接受参数</span>\n        String groupId = invocation.getAttachment(TracingConstants.HEADER_KEY_GROUP_ID, <span class=\"hljs-string\">\"\"</span>);\n        String appList = invocation.getAttachment(TracingConstants.HEADER_KEY_APP_MAP, <span class=\"hljs-string\">\"\"</span>);\n        <span class=\"hljs-comment\">//设置参数</span>\n        TracingContext.tracing().init(Maps.newHashMap(TracingConstants.GROUP_ID, groupId, TracingConstants.APP_MAP, appList));\n        <span class=\"hljs-keyword\">return</span> invoker.invoke(invocation);\n    }\n}\n\n</code></pre>\n<ol start=\"2\">\n<li>负载均衡的扩展控制(仅限于LCN模式下)</li>\n</ol>\n<p>控制的效果：负载均衡扩展主要为了做到在同一次分布式事务中相同的模块重复调用在同一个模块下。</p>\n<p>为什么仅限于LCN模式？</p>\n<p>当存在这样的请求链,A模块先调用了B模块的one方法，然后在调用了two方法，如下所示：</p>\n<p>A -&gt;B.one();\nA -&gt;B.two();\n假如one与two方法的业务都是在修改同一条数据,假如两个方法的id相同，伪代码如下:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">one</span><span class=\"hljs-params\">(id)</span></span>{\n   execute =&gt; update demo set state = <span class=\"hljs-number\">1</span> where id = {id} ;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">two</span><span class=\"hljs-params\">(id)</span></span>{\n   execute =&gt; update demo set state = <span class=\"hljs-number\">2</span> where id = {id} ;\n}\n\n</code></pre>\n<p>若B模块做了集群存在B1、B2两个模块。那么就可能出现A分别调用了B1 B2模块，如下:</p>\n<p>A -&gt;B1.one();\nA -&gt;B2.two();\n在这样的情况下业务方将在LCN下会因为资源占用而导致执行失败而回滚事务。为了支持这样的场景，框架提供了重写了rpc的负载模式。</p>\n<p>控制在同一次事务下同一个被负载的模块被重复调用时将只会请求到第一次被选中的模块。在采用这样的方案的时候也会提高Connection的连接使用率，会提高在负载情况下的性能。</p>\n<p>dubbo框架默认提供了四种负载策略，这里仅仅展示random的实现。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TxlcnRandomLoadBalance</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RandomLoadBalance</span> </span>{\n\n   <span class=\"hljs-meta\">@Override</span>\n   <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">select</span><span class=\"hljs-params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>{\n       <span class=\"hljs-keyword\">return</span> DubboTxlcnLoadBalance.chooseInvoker(invokers, url, invocation, <span class=\"hljs-keyword\">super</span>::select);\n   }\n\n}\n\n<span class=\"hljs-meta\">@Slf</span>4j\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DubboTxlcnLoadBalance</span> </span>{\n\n   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String empty = <span class=\"hljs-string\">\"\"</span>;\n\n   <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">chooseInvoker</span><span class=\"hljs-params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation, TxLcnLoadBalance loadBalance)</span> </span>{\n\n       <span class=\"hljs-comment\">//非分布式事务直接执行默认业务.</span>\n       <span class=\"hljs-keyword\">if</span>(!TracingContext.tracing().hasGroup()){\n           <span class=\"hljs-keyword\">return</span> loadBalance.select(invokers, url, invocation);\n       }\n       TracingContext.tracing()\n               .addApp(RpcContext.getContext().getLocalAddressString(), empty);\n       <span class=\"hljs-keyword\">assert</span> invokers.size() &gt; <span class=\"hljs-number\">0</span>;\n       JSONObject appMap = TracingContext.tracing().appMap();\n       log.debug(<span class=\"hljs-string\">\"invokers: {}\"</span>, invokers);\n       Invoker&lt;T&gt; chooseInvoker = <span class=\"hljs-keyword\">null</span>;\n       outline:\n       <span class=\"hljs-keyword\">for</span> (Invoker&lt;T&gt; tInvoker : invokers) {\n           <span class=\"hljs-keyword\">for</span> (String address : appMap.keySet()) {\n               <span class=\"hljs-keyword\">if</span> (address.equals(tInvoker.getUrl().getAddress())) {\n                   chooseInvoker = tInvoker;\n                   log.debug(<span class=\"hljs-string\">\"txlcn choosed server [{}] in txGroup: {}\"</span>, tInvoker, TracingContext.tracing().groupId());\n                   <span class=\"hljs-keyword\">break</span> outline;\n               }\n           }\n       }\n       <span class=\"hljs-keyword\">if</span> (chooseInvoker == <span class=\"hljs-keyword\">null</span>) {\n           Invoker&lt;T&gt; invoker = loadBalance.select(invokers, url, invocation);\n           TracingContext.tracing().addApp(invoker.getUrl().getAddress(), empty);\n           <span class=\"hljs-keyword\">return</span> invoker;\n       }\n       <span class=\"hljs-keyword\">return</span> chooseInvoker;\n   }\n\n   <span class=\"hljs-meta\">@FunctionalInterface</span>\n   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">TxLcnLoadBalance</span> </span>{\n       &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">select</span><span class=\"hljs-params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;\n   }\n}\n</code></pre>\n",
  "link": "\\zh-cn\\docs\\expansion\\rpc.html",
  "meta": {}
}